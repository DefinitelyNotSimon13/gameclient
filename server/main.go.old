package main

// Things that will need to be saved during runtime:
// - connected players
// - active sessions
// - sessions -> players
// Possible future persitant:
// - "stats"

import (
	"encoding/binary"
	"fmt"
	"log"
	"math"
	"net"
	"os"
	"sync"
)

const (
	PacketVersion0 = 0
)

var (
	udpClients = make(map[uint32]*net.UDPAddr)
	mu         sync.Mutex
)

type Connection struct {
	Id      int
	UdpAddr net.UDPAddr
}

func main() {
	addr := "localhost:9000"

	// --- TCP ---
	listener, err := net.Listen("tcp", addr)
	if err != nil {
		log.Fatalf("Error starting TCP server: %v\n", err)
	}
	defer listener.Close()
	log.Printf("TCP server is listening on %s\n", addr)


	go func() {

	var id uint32
		for {
			tcpConn, err := listener.Accept()
			if err != nil {
				log.Printf("Error accepting TCP connection: %v\n", err)
				continue
			}

			id++
			go handleTCPConnection(tcpConn, id)
		}
	}()

	// --- UDP ---
	udpAddr, err := net.ResolveUDPAddr("udp", addr)
	if err != nil {
		log.Fatalf("Error resolving UDP addr: %v\n", err)
	}

	udpConn, err := net.ListenUDP("udp", udpAddr)
	if err != nil {
		log.Fatalf("Error starting UDP server: %v\n")
	}
	defer udpConn.Close()

	log.Printf("UDP server is listening on %s\n", addr)

	handleUDPConnection(udpConn)
}

func handleTCPConnection(conn net.Conn, id uint32) {
	defer conn.Close()

	bs := make([]byte, 4)
	binary.LittleEndian.PutUint32(bs, id)

    log.Printf("Assigned ID %d -> Writing bytes: %v\n", id, bs)

	_, err := conn.Write(bs)
	if err != nil {
		log.Printf("Error sending TCP message: %v\n", err)
		return
	}

	log.Printf("Sent greeting to %v\n", conn.RemoteAddr())
}

func handleUDPConnection(conn *net.UDPConn) {
	buf := make([]byte, 1024)

	for {
		n, remoteAddr, err := conn.ReadFromUDP(buf)
		if err != nil {
			log.Printf("Error reading UDP data: %v\m", err)
			continue
		}

		if n < 1 {
			log.Println("Received less then 1 byte, can't read version\n")
			continue
		}

		// first 4 bytes from
		version := buf[0] & 0x0F
		switch version {
		case PacketVersion0:
			handlePacketV0(conn, buf, n, remoteAddr)
		default:
			log.Printf("Unknown version (%d) from %v\n", version, remoteAddr)
		}
	}
}

func handlePacketV0(conn *net.UDPConn, data []byte, length int, remoteAddr *net.UDPAddr) {
	if length < 17 {
		log.Fatal("Received to few bytes for PacketVersion 0")
		return
	}

	senderId := binary.LittleEndian.Uint32(data[1 : 1+4])

	xBits := binary.LittleEndian.Uint32(data[5 : 9])
	yBits := binary.LittleEndian.Uint32(data[9 : 13])
	zBits := binary.LittleEndian.Uint32(data[13 : 17])

	x := math.Float32frombits(xBits)
	y := math.Float32frombits(yBits)
	z := math.Float32frombits(zBits)

	log.Printf("V0 packet from %v with ID %d => x=%f, y=%f, z=%f\n", remoteAddr, senderId, x, y, z)

	mu.Lock()
	if _, ok := udpClients[senderId]; !ok {
		udpClients[senderId] = remoteAddr
		fmt.Printf("Registered new UDP client with ID %d at %v\n", senderId, remoteAddr)
	}
	mu.Unlock()

	mu.Lock()
	for clientId, clientAddr := range udpClients {
		if clientId == senderId {
			continue
		}

		_, err := conn.WriteToUDP(data[:length], clientAddr)
		if err != nil {
			log.Printf("Error broadcasting to client %d at %v: %v\n", clientId, clientAddr, err)
		}
	}
	mu.Unlock()
}
